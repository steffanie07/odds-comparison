{"version":3,"sources":["@wordpress/rich-text/src/to-tree.js"],"names":["getActiveFormats","getFormatType","LINE_SEPARATOR","OBJECT_REPLACEMENT_CHARACTER","ZWNBSP","restoreOnAttributes","attributes","isEditableTree","newAttributes","key","newKey","startsWith","slice","length","fromFormat","type","tagName","unregisteredAttributes","object","boundaryClass","formatType","elementAttributes","name","className","class","contentEditable","contenteditable","isEqualUntil","a","b","index","toTree","value","multilineTag","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","placeholder","formats","replacements","text","start","end","formatsLength","tree","multilineFormat","activeFormats","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","characterFormats","reduce","accumulator","format","push","pointer","node","forEach","formatIndex","parent","newNode","replacement","innerHTML","html","decodeURIComponent","undefined","style"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\nfunction restoreOnAttributes( attributes, isEditableTree ) {\n\tif ( isEditableTree ) {\n\t\treturn attributes;\n\t}\n\n\tconst newAttributes = {};\n\n\tfor ( const key in attributes ) {\n\t\tlet newKey = key;\n\t\tif ( key.startsWith( 'data-disable-rich-text-' ) ) {\n\t\t\tnewKey = key.slice( 'data-disable-rich-text-'.length );\n\t\t}\n\n\t\tnewAttributes[ newKey ] = attributes[ key ];\n\t}\n\n\treturn newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat( {\n\ttype,\n\ttagName,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n\tisEditableTree,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass && isEditableTree ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tattributes: restoreOnAttributes(\n\t\t\t\telementAttributes,\n\t\t\t\tisEditableTree\n\t\t\t),\n\t\t\tobject,\n\t\t};\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\t// When a format is declared as non editable, make it non editable in the\n\t// editor.\n\tif ( isEditableTree && formatType.contentEditable === false ) {\n\t\telementAttributes.contenteditable = 'false';\n\t}\n\n\treturn {\n\t\ttype: tagName || formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: restoreOnAttributes( elementAttributes, isEditableTree ),\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, tagName, attributes, unregisteredAttributes } =\n\t\t\t\t\tformat;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\ttagName,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tconst replacement = replacements[ i ];\n\t\t\tif ( ! replacement ) continue;\n\t\t\tconst { type, attributes, innerHTML } = replacement;\n\t\t\tconst formatType = getFormatType( type );\n\n\t\t\tif ( ! isEditableTree && type === 'script' ) {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype: 'script',\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t\tappend( pointer, {\n\t\t\t\t\thtml: decodeURIComponent(\n\t\t\t\t\t\tattributes[ 'data-rich-text-script' ]\n\t\t\t\t\t),\n\t\t\t\t} );\n\t\t\t} else if ( formatType?.contentEditable === false ) {\n\t\t\t\t// For non editable formats, render the stored inner HTML.\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t\tboundaryClass: start === i && end === i + 1,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( innerHTML ) {\n\t\t\t\t\tappend( pointer, {\n\t\t\t\t\t\thtml: innerHTML,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpointer = append(\n\t\t\t\t\tgetParent( pointer ),\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\t...replacement,\n\t\t\t\t\t\tobject: true,\n\t\t\t\t\t\tisEditableTree,\n\t\t\t\t\t} )\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection. The placeholder is also not editable after\n\t\t\t\t\t\t// all.\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t\tstyle: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"]}