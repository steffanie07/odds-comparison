{"version":3,"sources":["@wordpress/rich-text/src/to-dom.js"],"names":["toTree","createElement","isRangeEqual","createPathToNode","node","rootNode","path","parentNode","i","previousSibling","getNodeByPath","length","childNodes","shift","offset","append","element","child","html","undefined","innerHTML","ownerDocument","createTextNode","type","attributes","key","setAttribute","appendChild","appendText","text","appendData","getLastChild","lastChild","getParent","isText","nodeType","TEXT_NODE","getText","nodeValue","remove","removeChild","toDom","value","multilineTag","prepareEditableTree","isEditableTree","placeholder","doc","document","startPath","endPath","formats","createEmpty","tree","onStartIndex","body","pointer","onEndIndex","selection","apply","current","__unstableDomOnly","applyValue","start","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","nodeName","data","replaceChild","currentAttributes","futureAttributes","ii","name","getAttribute","removeAttribute","startContainer","startOffset","endContainer","endOffset","defaultView","getSelection","range","createRange","setStart","setEnd","activeElement","rangeCount","getRangeAt","removeAllRanges","addRange","HTMLElement","focus"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\nimport { isRangeEqual } from './is-range-equal';\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( child.html !== undefined ) {\n\t\treturn ( element.innerHTML += child.html );\n\t}\n\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {string}        [$1.multilineTag]        Multiline tag.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n"]}