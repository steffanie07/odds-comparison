"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withBehaviors = void 0;

var _element = require("@wordpress/element");

var _hooks = require("@wordpress/hooks");

var _components = require("@wordpress/components");

var _i18n = require("@wordpress/i18n");

var _blocks = require("@wordpress/blocks");

var _compose = require("@wordpress/compose");

var _data = require("@wordpress/data");

var _store = require("../store");

var _components2 = require("../components");

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */
function BehaviorsControl({
  blockName,
  blockBehaviors,
  onChangeBehavior,
  onChangeAnimation,
  disabled = false
}) {
  const {
    settings,
    themeBehaviors
  } = (0, _data.useSelect)(select => {
    const {
      getBehaviors,
      getSettings
    } = select(_store.store);
    return {
      settings: getSettings()?.__experimentalFeatures?.blocks?.[blockName]?.behaviors,
      themeBehaviors: getBehaviors()?.blocks?.[blockName]
    };
  }, [blockName]);
  const defaultBehaviors = {
    default: {
      value: 'default',
      label: (0, _i18n.__)('Default')
    },
    noBehaviors: {
      value: '',
      label: (0, _i18n.__)('No behaviors')
    }
  };
  const behaviorsOptions = Object.entries(settings).filter(([behaviorName, behaviorValue]) => (0, _blocks.hasBlockSupport)(blockName, `behaviors.${behaviorName}`) && behaviorValue) // Filter out behaviors that are disabled.
  .map(([behaviorName]) => ({
    value: behaviorName,
    // Capitalize the first letter of the behavior name.
    label: `${behaviorName.charAt(0).toUpperCase()}${behaviorName.slice(1).toLowerCase()}`
  }));
  const options = [...Object.values(defaultBehaviors), ...behaviorsOptions];
  const {
    behaviors,
    behaviorsValue
  } = (0, _element.useMemo)(() => {
    const mergedBehaviors = { ...themeBehaviors,
      ...(blockBehaviors || {})
    };
    let value = '';

    if (blockBehaviors === undefined) {
      value = 'default';
    }

    if (blockBehaviors?.lightbox.enabled) {
      value = 'lightbox';
    }

    return {
      behaviors: mergedBehaviors,
      behaviorsValue: value
    };
  }, [blockBehaviors, themeBehaviors]); // If every behavior is disabled, do not show the behaviors inspector control.

  if (behaviorsOptions.length === 0) {
    return null;
  }

  const helpText = disabled ? (0, _i18n.__)('The lightbox behavior is disabled for linked images.') : '';
  return (0, _element.createElement)(_components2.InspectorControls, {
    group: "advanced"
  }, (0, _element.createElement)("div", null, (0, _element.createElement)(_components.SelectControl, {
    label: (0, _i18n.__)('Behaviors') // At the moment we are only supporting one behavior (Lightbox)
    ,
    value: behaviorsValue,
    options: options,
    onChange: onChangeBehavior,
    hideCancelButton: true,
    help: helpText,
    size: "__unstable-large",
    disabled: disabled
  }), behaviorsValue === 'lightbox' && (0, _element.createElement)(_components.SelectControl, {
    label: (0, _i18n.__)('Animation') // At the moment we are only supporting one behavior (Lightbox)
    ,
    value: behaviors?.lightbox.animation ? behaviors?.lightbox.animation : '',
    options: [{
      value: 'zoom',
      label: (0, _i18n.__)('Zoom')
    }, {
      value: 'fade',
      label: (0, _i18n.__)('Fade')
    }],
    onChange: onChangeAnimation,
    hideCancelButton: false,
    size: "__unstable-large",
    disabled: disabled
  })));
}
/**
 * Override the default edit UI to include a new block inspector control for
 * assigning behaviors to blocks if behaviors are enabled in the theme.json.
 *
 * Currently, only the `core/image` block is supported.
 *
 * @param {WPComponent} BlockEdit Original component.
 *
 * @return {WPComponent} Wrapped component.
 */


const withBehaviors = (0, _compose.createHigherOrderComponent)(BlockEdit => {
  return props => {
    const blockEdit = (0, _element.createElement)(BlockEdit, {
      key: "edit",
      ...props
    }); // Only add behaviors to blocks with support.

    if (!(0, _blocks.hasBlockSupport)(props.name, 'behaviors')) {
      return blockEdit;
    }

    const blockHasLink = typeof props.attributes?.linkDestination !== 'undefined' && props.attributes?.linkDestination !== 'none';
    return (0, _element.createElement)(_element.Fragment, null, blockEdit, (0, _element.createElement)(BehaviorsControl, {
      blockName: props.name,
      blockBehaviors: props.attributes.behaviors,
      onChangeBehavior: nextValue => {
        if (nextValue === 'default') {
          props.setAttributes({
            behaviors: undefined
          });
        } else {
          // If the user selects something, it means that they want to
          // change the default value (true) so we save it in the attributes.
          props.setAttributes({
            behaviors: {
              lightbox: {
                enabled: nextValue === 'lightbox',
                animation: nextValue === 'lightbox' ? 'zoom' : ''
              }
            }
          });
        }
      },
      onChangeAnimation: nextValue => {
        props.setAttributes({
          behaviors: {
            lightbox: {
              enabled: props.attributes.behaviors.lightbox.enabled,
              animation: nextValue
            }
          }
        });
      },
      disabled: blockHasLink
    }));
  };
}, 'withBehaviors');
exports.withBehaviors = withBehaviors;

if (window?.__experimentalInteractivityAPI) {
  (0, _hooks.addFilter)('editor.BlockEdit', 'core/behaviors/with-inspector-control', withBehaviors);
}
//# sourceMappingURL=behaviors.js.map