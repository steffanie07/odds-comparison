{"version":3,"sources":["@wordpress/block-editor/src/components/font-sizes/fluid-utils.js"],"names":["DEFAULT_MAXIMUM_VIEWPORT_WIDTH","DEFAULT_MINIMUM_VIEWPORT_WIDTH","DEFAULT_SCALE_FACTOR","DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN","DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX","DEFAULT_MINIMUM_FONT_SIZE_LIMIT","getComputedFluidTypographyValue","minimumFontSize","maximumFontSize","fontSize","minimumViewPortWidth","maximumViewPortWidth","scaleFactor","minimumFontSizeLimit","getTypographyValueAndUnit","fontSizeParsed","unit","minimumFontSizeLimitParsed","coerceTo","value","fontSizeValueInPx","minimumFontSizeFactor","Math","min","max","log2","calculatedMinimumFontSize","roundToPrecision","minimumFontSizeParsed","fontSizeUnit","maximumFontSizeParsed","minimumFontSizeRem","maximumViewPortWidthParsed","minumumViewPortWidthParsed","minViewPortWidthOffsetValue","viewPortWidthOffset","linearFactor","linearFactorScaled","fluidTargetFontSize","rawValue","options","isFinite","rootSizeValue","acceptableUnits","acceptableUnitsGroup","join","regexUnits","RegExp","matches","match","length","returnValue","parseFloat","digits","base","pow","Number","round","undefined"],"mappings":"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","sourcesContent":["/**\n * The fluid utilities must match the backend equivalent.\n * See: gutenberg_get_typography_font_size_value() in lib/block-supports/typography.php\n * ---------------------------------------------------------------\n */\n\n// Defaults.\nconst DEFAULT_MAXIMUM_VIEWPORT_WIDTH = '1600px';\nconst DEFAULT_MINIMUM_VIEWPORT_WIDTH = '320px';\nconst DEFAULT_SCALE_FACTOR = 1;\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN = 0.25;\nconst DEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX = 0.75;\nconst DEFAULT_MINIMUM_FONT_SIZE_LIMIT = '14px';\n\n/**\n * Computes a fluid font-size value that uses clamp(). A minimum and maximum\n * font size OR a single font size can be specified.\n *\n * If a single font size is specified, it is scaled up and down using a logarithmic scale.\n *\n * @example\n * ```js\n * // Calculate fluid font-size value from a minimum and maximum value.\n * const fontSize = getComputedFluidTypographyValue( {\n *     minimumFontSize: '20px',\n *     maximumFontSize: '45px'\n * } );\n * // Calculate fluid font-size value from a single font size.\n * const fontSize = getComputedFluidTypographyValue( {\n *     fontSize: '30px',\n * } );\n * ```\n *\n * @param {Object}        args\n * @param {?string}       args.minimumViewPortWidth Minimum viewport size from which type will have fluidity. Optional if fontSize is specified.\n * @param {?string}       args.maximumViewPortWidth Maximum size up to which type will have fluidity. Optional if fontSize is specified.\n * @param {string|number} [args.fontSize]           Size to derive maximumFontSize and minimumFontSize from, if necessary. Optional if minimumFontSize and maximumFontSize are specified.\n * @param {?string}       args.maximumFontSize      Maximum font size for any clamp() calculation. Optional.\n * @param {?string}       args.minimumFontSize      Minimum font size for any clamp() calculation. Optional.\n * @param {?number}       args.scaleFactor          A scale factor to determine how fast a font scales within boundaries. Optional.\n * @param {?string}       args.minimumFontSizeLimit The smallest a calculated font size may be. Optional.\n *\n * @return {string|null} A font-size value using clamp().\n */\nexport function getComputedFluidTypographyValue( {\n\tminimumFontSize,\n\tmaximumFontSize,\n\tfontSize,\n\tminimumViewPortWidth = DEFAULT_MINIMUM_VIEWPORT_WIDTH,\n\tmaximumViewPortWidth = DEFAULT_MAXIMUM_VIEWPORT_WIDTH,\n\tscaleFactor = DEFAULT_SCALE_FACTOR,\n\tminimumFontSizeLimit,\n} ) {\n\t// Validate incoming settings and set defaults.\n\tminimumFontSizeLimit = !! getTypographyValueAndUnit( minimumFontSizeLimit )\n\t\t? minimumFontSizeLimit\n\t\t: DEFAULT_MINIMUM_FONT_SIZE_LIMIT;\n\n\t/*\n\t * Calculates missing minimumFontSize and maximumFontSize from\n\t * defaultFontSize if provided.\n\t */\n\tif ( fontSize ) {\n\t\t// Parses default font size.\n\t\tconst fontSizeParsed = getTypographyValueAndUnit( fontSize );\n\n\t\t// Protect against invalid units.\n\t\tif ( ! fontSizeParsed?.unit ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Parses the minimum font size limit, so we can perform checks using it.\n\t\tconst minimumFontSizeLimitParsed = getTypographyValueAndUnit(\n\t\t\tminimumFontSizeLimit,\n\t\t\t{\n\t\t\t\tcoerceTo: fontSizeParsed.unit,\n\t\t\t}\n\t\t);\n\n\t\t// Don't enforce minimum font size if a font size has explicitly set a min and max value.\n\t\tif (\n\t\t\t!! minimumFontSizeLimitParsed?.value &&\n\t\t\t! minimumFontSize &&\n\t\t\t! maximumFontSize\n\t\t) {\n\t\t\t/*\n\t\t\t * If a minimum size was not passed to this function\n\t\t\t * and the user-defined font size is lower than $minimum_font_size_limit,\n\t\t\t * do not calculate a fluid value.\n\t\t\t */\n\t\t\tif ( fontSizeParsed?.value <= minimumFontSizeLimitParsed?.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// If no fluid max font size is available use the incoming value.\n\t\tif ( ! maximumFontSize ) {\n\t\t\tmaximumFontSize = `${ fontSizeParsed.value }${ fontSizeParsed.unit }`;\n\t\t}\n\n\t\t/*\n\t\t * If no minimumFontSize is provided, create one using\n\t\t * the given font size multiplied by the min font size scale factor.\n\t\t */\n\t\tif ( ! minimumFontSize ) {\n\t\t\tconst fontSizeValueInPx =\n\t\t\t\tfontSizeParsed.unit === 'px'\n\t\t\t\t\t? fontSizeParsed.value\n\t\t\t\t\t: fontSizeParsed.value * 16;\n\n\t\t\t/*\n\t\t\t * The scale factor is a multiplier that affects how quickly the curve will move towards the minimum,\n\t\t\t * that is, how quickly the size factor reaches 0 given increasing font size values.\n\t\t\t * For a - b * log2(), lower values of b will make the curve move towards the minimum faster.\n\t\t\t * The scale factor is constrained between min and max values.\n\t\t\t */\n\t\t\tconst minimumFontSizeFactor = Math.min(\n\t\t\t\tMath.max(\n\t\t\t\t\t1 - 0.075 * Math.log2( fontSizeValueInPx ),\n\t\t\t\t\tDEFAULT_MINIMUM_FONT_SIZE_FACTOR_MIN\n\t\t\t\t),\n\t\t\t\tDEFAULT_MINIMUM_FONT_SIZE_FACTOR_MAX\n\t\t\t);\n\n\t\t\t// Calculates the minimum font size.\n\t\t\tconst calculatedMinimumFontSize = roundToPrecision(\n\t\t\t\tfontSizeParsed.value * minimumFontSizeFactor,\n\t\t\t\t3\n\t\t\t);\n\n\t\t\t// Only use calculated min font size if it's > $minimum_font_size_limit value.\n\t\t\tif (\n\t\t\t\t!! minimumFontSizeLimitParsed?.value &&\n\t\t\t\tcalculatedMinimumFontSize < minimumFontSizeLimitParsed?.value\n\t\t\t) {\n\t\t\t\tminimumFontSize = `${ minimumFontSizeLimitParsed.value }${ minimumFontSizeLimitParsed.unit }`;\n\t\t\t} else {\n\t\t\t\tminimumFontSize = `${ calculatedMinimumFontSize }${ fontSizeParsed.unit }`;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Grab the minimum font size and normalize it in order to use the value for calculations.\n\tconst minimumFontSizeParsed = getTypographyValueAndUnit( minimumFontSize );\n\n\t// We get a 'preferred' unit to keep units consistent when calculating,\n\t// otherwise the result will not be accurate.\n\tconst fontSizeUnit = minimumFontSizeParsed?.unit || 'rem';\n\n\t// Grabs the maximum font size and normalize it in order to use the value for calculations.\n\tconst maximumFontSizeParsed = getTypographyValueAndUnit( maximumFontSize, {\n\t\tcoerceTo: fontSizeUnit,\n\t} );\n\n\t// Checks for mandatory min and max sizes, and protects against unsupported units.\n\tif ( ! minimumFontSizeParsed || ! maximumFontSizeParsed ) {\n\t\treturn null;\n\t}\n\n\t// Uses rem for accessible fluid target font scaling.\n\tconst minimumFontSizeRem = getTypographyValueAndUnit( minimumFontSize, {\n\t\tcoerceTo: 'rem',\n\t} );\n\n\t// Viewport widths defined for fluid typography. Normalize units\n\tconst maximumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tmaximumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\tconst minumumViewPortWidthParsed = getTypographyValueAndUnit(\n\t\tminimumViewPortWidth,\n\t\t{ coerceTo: fontSizeUnit }\n\t);\n\n\t// Protect against unsupported units.\n\tif (\n\t\t! maximumViewPortWidthParsed ||\n\t\t! minumumViewPortWidthParsed ||\n\t\t! minimumFontSizeRem\n\t) {\n\t\treturn null;\n\t}\n\n\t// Build CSS rule.\n\t// Borrowed from https://websemantics.uk/tools/responsive-font-calculator/.\n\tconst minViewPortWidthOffsetValue = roundToPrecision(\n\t\tminumumViewPortWidthParsed.value / 100,\n\t\t3\n\t);\n\n\tconst viewPortWidthOffset =\n\t\troundToPrecision( minViewPortWidthOffsetValue, 3 ) + fontSizeUnit;\n\tconst linearFactor =\n\t\t100 *\n\t\t( ( maximumFontSizeParsed.value - minimumFontSizeParsed.value ) /\n\t\t\t( maximumViewPortWidthParsed.value -\n\t\t\t\tminumumViewPortWidthParsed.value ) );\n\tconst linearFactorScaled = roundToPrecision(\n\t\t( linearFactor || 1 ) * scaleFactor,\n\t\t3\n\t);\n\tconst fluidTargetFontSize = `${ minimumFontSizeRem.value }${ minimumFontSizeRem.unit } + ((1vw - ${ viewPortWidthOffset }) * ${ linearFactorScaled })`;\n\n\treturn `clamp(${ minimumFontSize }, ${ fluidTargetFontSize }, ${ maximumFontSize })`;\n}\n\n/**\n * Internal method that checks a string for a unit and value and returns an array consisting of `'value'` and `'unit'`, e.g., [ '42', 'rem' ].\n * A raw font size of `value + unit` is expected. If the value is an integer, it will convert to `value + 'px'`.\n *\n * @param {string|number}    rawValue Raw size value from theme.json.\n * @param {Object|undefined} options  Calculation options.\n *\n * @return {{ unit: string, value: number }|null} An object consisting of `'value'` and `'unit'` properties.\n */\nexport function getTypographyValueAndUnit( rawValue, options = {} ) {\n\tif ( typeof rawValue !== 'string' && typeof rawValue !== 'number' ) {\n\t\treturn null;\n\t}\n\n\t// Converts numeric values to pixel values by default.\n\tif ( isFinite( rawValue ) ) {\n\t\trawValue = `${ rawValue }px`;\n\t}\n\n\tconst { coerceTo, rootSizeValue, acceptableUnits } = {\n\t\tcoerceTo: '',\n\t\t// Default browser font size. Later we could inject some JS to compute this `getComputedStyle( document.querySelector( \"html\" ) ).fontSize`.\n\t\trootSizeValue: 16,\n\t\tacceptableUnits: [ 'rem', 'px', 'em' ],\n\t\t...options,\n\t};\n\n\tconst acceptableUnitsGroup = acceptableUnits?.join( '|' );\n\tconst regexUnits = new RegExp(\n\t\t`^(\\\\d*\\\\.?\\\\d+)(${ acceptableUnitsGroup }){1,1}$`\n\t);\n\n\tconst matches = rawValue.match( regexUnits );\n\n\t// We need a number value and a unit.\n\tif ( ! matches || matches.length < 3 ) {\n\t\treturn null;\n\t}\n\n\tlet [ , value, unit ] = matches;\n\n\tlet returnValue = parseFloat( value );\n\n\tif ( 'px' === coerceTo && ( 'em' === unit || 'rem' === unit ) ) {\n\t\treturnValue = returnValue * rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\tif ( 'px' === unit && ( 'em' === coerceTo || 'rem' === coerceTo ) ) {\n\t\treturnValue = returnValue / rootSizeValue;\n\t\tunit = coerceTo;\n\t}\n\n\t/*\n\t * No calculation is required if swapping between em and rem yet,\n\t * since we assume a root size value. Later we might like to differentiate between\n\t * :root font size (rem) and parent element font size (em) relativity.\n\t */\n\tif (\n\t\t( 'em' === coerceTo || 'rem' === coerceTo ) &&\n\t\t( 'em' === unit || 'rem' === unit )\n\t) {\n\t\tunit = coerceTo;\n\t}\n\n\treturn {\n\t\tvalue: roundToPrecision( returnValue, 3 ),\n\t\tunit,\n\t};\n}\n\n/**\n * Returns a value rounded to defined precision.\n * Returns `undefined` if the value is not a valid finite number.\n *\n * @param {number} value  Raw value.\n * @param {number} digits The number of digits to appear after the decimal point\n *\n * @return {number|undefined} Value rounded to standard precision.\n */\nexport function roundToPrecision( value, digits = 3 ) {\n\tconst base = Math.pow( 10, digits );\n\treturn Number.isFinite( value )\n\t\t? parseFloat( Math.round( value * base ) / base )\n\t\t: undefined;\n}\n"]}