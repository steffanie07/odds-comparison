"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBlockEditingMode = getBlockEditingMode;
exports.getBlockRemovalRules = getBlockRemovalRules;
exports.getEnabledClientIdsTree = exports.getEnabledBlockParents = void 0;
exports.getLastInsertedBlocksClientIds = getLastInsertedBlocksClientIds;
exports.getRemovalPromptData = getRemovalPromptData;
exports.isBlockInterfaceHidden = isBlockInterfaceHidden;
exports.isBlockSubtreeDisabled = void 0;

var _rememo = _interopRequireDefault(require("rememo"));

var _data = require("@wordpress/data");

var _blocks = require("@wordpress/blocks");

var _selectors = require("./selectors");

/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Returns true if the block interface is hidden, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the block toolbar is hidden.
 */
function isBlockInterfaceHidden(state) {
  return state.isBlockInterfaceHidden;
}
/**
 * Gets the client ids of the last inserted blocks.
 *
 * @param {Object} state Global application state.
 * @return {Array|undefined} Client Ids of the last inserted block(s).
 */


function getLastInsertedBlocksClientIds(state) {
  return state?.lastBlockInserted?.clientIds;
}
/**
 * @typedef {import('../components/block-editing-mode').BlockEditingMode} BlockEditingMode
 */

/**
 * Returns the block editing mode for a given block.
 *
 * The mode can be one of three options:
 *
 * - `'disabled'`: Prevents editing the block entirely, i.e. it cannot be
 *   selected.
 * - `'contentOnly'`: Hides all non-content UI, e.g. auxiliary controls in the
 *   toolbar, the block movers, block settings.
 * - `'default'`: Allows editing the block as normal.
 *
 * Blocks can set a mode using the `useBlockEditingMode` hook.
 *
 * The mode is inherited by all of the block's inner blocks, unless they have
 * their own mode.
 *
 * A template lock can also set a mode. If the template lock is `'contentOnly'`,
 * the block's mode is overridden to `'contentOnly'` if the block has a content
 * role attribute, or `'disabled'` otherwise.
 *
 * @see useBlockEditingMode
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID, or `''` for the root container.
 *
 * @return {BlockEditingMode} The block editing mode. One of `'disabled'`,
 *                            `'contentOnly'`, or `'default'`.
 */


function getBlockEditingMode(state, clientId = '') {
  if (state.blockEditingModes.has(clientId)) {
    return state.blockEditingModes.get(clientId);
  }

  if (!clientId) {
    return 'default';
  }

  const rootClientId = (0, _selectors.getBlockRootClientId)(state, clientId);
  const templateLock = (0, _selectors.getTemplateLock)(state, rootClientId);

  if (templateLock === 'contentOnly') {
    const name = (0, _selectors.getBlockName)(state, clientId); // TODO: Terrible hack! We're calling the global select() function
    // here instead of using createRegistrySelector(). The problem with
    // using createRegistrySelector() is that then the public
    // block-editor selectors (e.g. canInsertBlockTypeUnmemoized) can't
    // call this private block-editor selector due to a bug in
    // @wordpress/data. See
    // https://github.com/WordPress/gutenberg/pull/50985.

    const isContent = (0, _data.select)(_blocks.store).__experimentalHasContentRoleAttribute(name);

    return isContent ? 'contentOnly' : 'disabled';
  }

  const parentMode = getBlockEditingMode(state, rootClientId);
  return parentMode === 'contentOnly' ? 'default' : parentMode;
}
/**
 * Returns true if the block with the given client ID and all of its descendants
 * have an editing mode of 'disabled', or false otherwise.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID.
 *
 * @return {boolean} Whether the block and its descendants are disabled.
 */


const isBlockSubtreeDisabled = (0, _rememo.default)((state, clientId) => {
  const isChildSubtreeDisabled = childClientId => {
    const mode = state.blockEditingModes.get(childClientId);
    return (mode === undefined || mode === 'disabled') && (0, _selectors.getBlockOrder)(state, childClientId).every(isChildSubtreeDisabled);
  };

  return getBlockEditingMode(state, clientId) === 'disabled' && (0, _selectors.getBlockOrder)(state, clientId).every(isChildSubtreeDisabled);
}, state => [state.blockEditingModes, state.blocks.parents]);
/**
 * Returns a tree of block objects with only clientID and innerBlocks set.
 * Blocks with a 'disabled' editing mode are not included.
 *
 * @param {Object}  state        Global application state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Tree of block objects with only clientID and innerBlocks set.
 */

exports.isBlockSubtreeDisabled = isBlockSubtreeDisabled;
const getEnabledClientIdsTree = (0, _rememo.default)((state, rootClientId = '') => {
  return (0, _selectors.getBlockOrder)(state, rootClientId).flatMap(clientId => {
    if (getBlockEditingMode(state, clientId) !== 'disabled') {
      return [{
        clientId,
        innerBlocks: getEnabledClientIdsTree(state, clientId)
      }];
    }

    return getEnabledClientIdsTree(state, clientId);
  });
}, state => [state.blocks.order, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);
/**
 * Returns a list of a given block's ancestors, from top to bottom. Blocks with
 * a 'disabled' editing mode are excluded.
 *
 * @see getBlockParents
 *
 * @param {Object}  state     Global application state.
 * @param {string}  clientId  The block client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top
 *                            to bottom (false).
 */

exports.getEnabledClientIdsTree = getEnabledClientIdsTree;
const getEnabledBlockParents = (0, _rememo.default)((state, clientId, ascending = false) => {
  return (0, _selectors.getBlockParents)(state, clientId, ascending).filter(parent => getBlockEditingMode(state, parent) !== 'disabled');
}, state => [state.blocks.parents, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);
/**
 * Selector that returns the data needed to display a prompt when certain
 * blocks are removed, or `false` if no such prompt is requested.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */

exports.getEnabledBlockParents = getEnabledBlockParents;

function getRemovalPromptData(state) {
  return state.removalPromptData;
}
/**
 * Returns true if removal prompt exists, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether removal prompt exists.
 */


function getBlockRemovalRules(state) {
  return state.blockRemovalRules;
}
//# sourceMappingURL=private-selectors.js.map