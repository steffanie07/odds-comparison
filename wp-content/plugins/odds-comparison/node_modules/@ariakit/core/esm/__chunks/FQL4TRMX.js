import {
  applyState,
  chain,
  getKeys,
  hasOwnProperty,
  noop,
  omit,
  pick
} from "./WVTCK5PV.js";
import {
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/utils/store.ts
function createStore(initialState, ...stores) {
  let state = initialState;
  let prevStateBatch = state;
  let lastUpdate = Symbol();
  let initialized = false;
  const updatedKeys = /* @__PURE__ */ new Set();
  const setups = /* @__PURE__ */ new Set();
  const listeners = /* @__PURE__ */ new Set();
  const listenersBatch = /* @__PURE__ */ new Set();
  const disposables = /* @__PURE__ */ new WeakMap();
  const listenerKeys = /* @__PURE__ */ new WeakMap();
  const setup = (callback) => {
    setups.add(callback);
    return () => setups.delete(callback);
  };
  const init = () => {
    if (initialized)
      return noop;
    if (!stores.length)
      return noop;
    initialized = true;
    const desyncs = getKeys(state).map(
      (key) => chain(
        ...stores.map((store) => {
          var _a, _b;
          const storeState = (_a = store == null ? void 0 : store.getState) == null ? void 0 : _a.call(store);
          if (!storeState)
            return;
          if (!hasOwnProperty(storeState, key))
            return;
          return (_b = store == null ? void 0 : store.sync) == null ? void 0 : _b.call(store, (state2) => setState(key, state2[key]), [key]);
        })
      )
    );
    const teardowns = [];
    setups.forEach((setup2) => teardowns.push(setup2()));
    const cleanups = stores.map((store) => {
      var _a;
      return (_a = store == null ? void 0 : store.init) == null ? void 0 : _a.call(store);
    });
    return chain(...desyncs, ...teardowns, ...cleanups, () => {
      initialized = false;
    });
  };
  const sub = (listener, keys, batch = false) => {
    const set = batch ? listenersBatch : listeners;
    set.add(listener);
    listenerKeys.set(listener, keys);
    return () => {
      var _a;
      (_a = disposables.get(listener)) == null ? void 0 : _a();
      disposables.delete(listener);
      listenerKeys.delete(listener);
      set.delete(listener);
    };
  };
  const subscribe = (listener, keys) => sub(listener, keys);
  const sync = (listener, keys) => {
    disposables.set(listener, listener(state, state));
    return sub(listener, keys);
  };
  const syncBatch = (listener, keys) => {
    disposables.set(listener, listener(state, prevStateBatch));
    return sub(listener, keys, true);
  };
  const getState = () => state;
  const setState = (key, value) => {
    if (!hasOwnProperty(state, key))
      return;
    const nextValue = applyState(value, state[key]);
    if (nextValue === state[key])
      return;
    stores.forEach((store) => {
      var _a;
      (_a = store == null ? void 0 : store.setState) == null ? void 0 : _a.call(store, key, nextValue);
    });
    const prevState = state;
    state = __spreadProps(__spreadValues({}, state), { [key]: nextValue });
    const thisUpdate = Symbol();
    lastUpdate = thisUpdate;
    updatedKeys.add(key);
    const run = (listener, prev, uKeys) => {
      var _a;
      const keys = listenerKeys.get(listener);
      const updated = (k) => uKeys ? uKeys.has(k) : k === key;
      if (!keys || keys.some(updated)) {
        (_a = disposables.get(listener)) == null ? void 0 : _a();
        disposables.set(listener, listener(state, prev));
      }
    };
    listeners.forEach((listener) => run(listener, prevState));
    queueMicrotask(() => {
      if (lastUpdate !== thisUpdate)
        return;
      const snapshot = state;
      listenersBatch.forEach((listener) => {
        run(listener, prevStateBatch, updatedKeys);
      });
      prevStateBatch = snapshot;
      updatedKeys.clear();
    });
  };
  const pick2 = (...keys) => createStore(pick(state, keys), finalStore);
  const omit2 = (...keys) => createStore(omit(state, keys), finalStore);
  const finalStore = {
    setup,
    init,
    subscribe,
    sync,
    syncBatch,
    getState,
    setState,
    pick: pick2,
    omit: omit2
  };
  return finalStore;
}
function mergeStore(...stores) {
  const initialState = stores.reduce((state, store2) => {
    var _a;
    const nextState = (_a = store2 == null ? void 0 : store2.getState) == null ? void 0 : _a.call(store2);
    if (!nextState)
      return state;
    return __spreadValues(__spreadValues({}, state), nextState);
  }, {});
  const store = createStore(initialState, ...stores);
  return store;
}

export {
  createStore,
  mergeStore
};
